import { OpenLibraryBook, OpenLibraryResponse, Book, BookCondition } from './types';
import { supabase } from './supabase';

// Base URL for Open Library API
const OPEN_LIBRARY_API_URL = 'https://openlibrary.org';

// Search for books by title, author, or ISBN
export const searchBooks = async (query: string): Promise<OpenLibraryBook[]> => {
  try {
    const response = await fetch(
      `${OPEN_LIBRARY_API_URL}/search.json?q=${encodeURIComponent(query)}&limit=10`
    );
    
    if (!response.ok) {
      throw new Error(`Error fetching book data: ${response.statusText}`);
    }
    
    const data: OpenLibraryResponse = await response.json();
    
    // Enhance the search results with additional data where possible
    const enhancedResults = await Promise.all(
      data.docs.map(async (book) => {
        // If we have a work key, try to fetch additional details
        if (book.key && book.key.startsWith('/works/')) {
          try {
            const workResponse = await fetch(`${OPEN_LIBRARY_API_URL}${book.key}.json`);
            if (workResponse.ok) {
              const workData = await workResponse.json();
              // Merge the work data with the search result
              return {
                ...book,
                description: workData.description || book.description,
                covers: workData.covers || book.covers
              };
            }
          } catch (error) {
            console.error('Error fetching additional book details:', error);
          }
        }
        return book;
      })
    );
    
    return enhancedResults;
  } catch (error) {
    console.error('Error searching books:', error);
    return [];
  }
};

// Get book cover image URL from Open Library
export const getBookCoverUrl = (coverId: number, size: 'S' | 'M' | 'L' = 'M'): string => {
  return `https://covers.openlibrary.org/b/id/${coverId}-${size}.jpg`;
};

// Format book data from Open Library for our database
export const formatBookData = (bookData: OpenLibraryBook): Partial<Book> => {
  // Process description field which can be a string or an object
  let description = '';
  
  if (typeof bookData.description === 'string') {
    description = bookData.description;
  } else if (bookData.description && typeof bookData.description === 'object' && 'value' in bookData.description) {
    description = bookData.description.value;
  }
  
  // Get author from either the authors array or author_name array
  let author = '';
  if (bookData.authors && bookData.authors.length > 0 && bookData.authors[0].name) {
    author = bookData.authors[0].name;
  } else if (bookData.author_name && bookData.author_name.length > 0) {
    author = bookData.author_name[0];
  }
  
  // Get ISBN from various possible fields
  let isbn = '';
  if (bookData.isbn_13 && bookData.isbn_13.length > 0) {
    isbn = bookData.isbn_13[0];
  } else if (bookData.isbn_10 && bookData.isbn_10.length > 0) {
    isbn = bookData.isbn_10[0];
  } else if (bookData.isbn && bookData.isbn.length > 0) {
    isbn = bookData.isbn[0];
  }
  
  // Get cover image URL if a cover ID is available
  let coverImgUrl = undefined;
  if (bookData.covers && bookData.covers.length > 0) {
    coverImgUrl = getBookCoverUrl(bookData.covers[0]);
  } else if (bookData.cover_i) {
    // Some search results use cover_i instead of covers array
    coverImgUrl = getBookCoverUrl(bookData.cover_i);
  }
  
  return {
    title: bookData.title,
    author,
    isbn,
    description,
    cover_img_url: coverImgUrl,
  };
};

// Add a new book to the database
export const addBook = async (
  userId: string,
  bookData: {
    title: string;
    author?: string;
    location_text: string;
    condition: BookCondition;
    cover_img_url?: string;
    isbn?: string;
    description?: string;
    postal_code?: string;
    lat?: number;
    lng?: number;
  }
): Promise<{ success: boolean; error?: string; book?: Book }> => {
  try {
    // Validate and process data before insert
    let processedData = {
      user_id: userId,
      ...bookData,
    };
    
    // Check if cover_img_url is a data URL and too large
    if (processedData.cover_img_url && processedData.cover_img_url.startsWith('data:')) {
      // If it's longer than 500KB (rough estimate for 1MB in DB), use a placeholder instead
      if (processedData.cover_img_url.length > 500000) {
        console.warn('Cover image too large for DB, replacing with placeholder');
        processedData.cover_img_url = 'https://via.placeholder.com/300x400?text=Book+Cover';
      }
    }
    
    // Note: location geography column will be automatically generated by the trigger
    // based on lat/lng values
    
    const { data, error } = await supabase
      .from('books')
      .insert(processedData)
      .select()
      .single();
      
    if (error) throw error;
    
    return { success: true, book: data as Book };
  } catch (error) {
    console.error('Error adding book:', error);
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Unknown error occurred' 
    };
  }
};

// Get all books for a user
export const getUserBooks = async (userId: string): Promise<Book[]> => {
  try {
    const { data, error } = await supabase
      .from('books')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false });
      
    if (error) throw error;
    
    return data as Book[];
  } catch (error) {
    console.error('Error getting user books:', error);
    return [];
  }
};

// Get all books (with optional limit)
export const getAllBooks = async (limit?: number): Promise<Book[]> => {
  try {
    let query = supabase
      .from('books')
      .select('*')
      .order('created_at', { ascending: false });
      
    if (limit) {
      query = query.limit(limit);
    }
    
    const { data, error } = await query;
      
    if (error) throw error;
    
    return data as Book[];
  } catch (error) {
    console.error('Error getting all books:', error);
    return [];
  }
};

// Get a book by ID
export const getBookById = async (bookId: string): Promise<Book | null> => {
  try {
    const { data, error } = await supabase
      .from('books')
      .select('*')
      .eq('id', bookId)
      .single();
      
    if (error) throw error;
    
    return data as Book;
  } catch (error) {
    console.error('Error getting book by ID:', error);
    return null;
  }
};

// Delete a book
export const deleteBook = async (bookId: string): Promise<{ success: boolean; error?: string }> => {
  try {
    const { error } = await supabase
      .from('books')
      .delete()
      .eq('id', bookId);
      
    if (error) throw error;
    
    return { success: true };
  } catch (error) {
    console.error('Error deleting book:', error);
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Unknown error occurred' 
    };
  }
};

// Update an existing book
export const updateBook = async (
  bookId: string,
  bookData: {
    title: string;
    author?: string;
    location_text: string;
    condition: BookCondition;
    cover_img_url?: string;
    isbn?: string;
    description?: string;
    postal_code?: string;
    lat?: number;
    lng?: number;
  }
): Promise<{ success: boolean; error?: string; book?: Book }> => {
  try {
    // Validate and process data before update
    let processedData = {
      ...bookData,
    };
    
    // Check if cover_img_url is a data URL and too large
    if (processedData.cover_img_url && processedData.cover_img_url.startsWith('data:')) {
      // If it's longer than 500KB (rough estimate for 1MB in DB), use a placeholder instead
      if (processedData.cover_img_url.length > 500000) {
        console.warn('Cover image too large for DB, replacing with placeholder');
        processedData.cover_img_url = 'https://via.placeholder.com/300x400?text=Book+Cover';
      }
    }
    
    // Note: location geography column will be automatically updated by the trigger
    // based on lat/lng values
    
    const { data, error } = await supabase
      .from('books')
      .update(processedData)
      .eq('id', bookId)
      .select()
      .single();
      
    if (error) throw error;
    
    return { success: true, book: data as Book };
  } catch (error) {
    console.error('Error updating book:', error);
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Unknown error occurred' 
    };
  }
};

// Get recently added books
export const getRecentlyAddedBooks = async (limit: number = 8): Promise<Book[]> => {
  try {
    const { data, error } = await supabase
      .from('books')
      .select('*')
      .order('created_at', { ascending: false })
      .limit(limit);
    
    if (error) {
      console.error('Error fetching recently added books:', error);
      return [];
    }
    
    return data || [];
  } catch (error) {
    console.error('Error fetching recently added books:', error);
    return [];
  }
};

// Search books by various parameters
export const searchBooksByParams = async (
  params: {
    title?: string;
    author?: string;
    postal_code?: string;
    radius?: number;
    latitude?: number;
    longitude?: number;
  }
): Promise<Book[]> => {
  try {
    // For location-based search, use the books_within_distance RPC function
    if (params.latitude && params.longitude && params.radius) {
      // Convert radius from km to meters for the query
      const radiusInMeters = params.radius * 1000;
      
      console.log('[bookService] Performing geographic search with params:', {
        search_lat: params.latitude,
        search_lng: params.longitude,
        max_distance_meters: radiusInMeters
      });
      
      // Use the correct function name and parameters matching the updated SQL
      const { data, error } = await supabase.rpc('books_within_distance', {
        search_lat: params.latitude,
        search_lng: params.longitude,
        max_distance_meters: radiusInMeters
      });
      
      if (error) {
        console.error('[bookService] Error performing geographic search:', error);
        
        // Fall back to regular search if geographic search fails
        console.log('[bookService] Falling back to non-geographic search due to error.');
        return fallbackSearch(params);
      } else {
        console.log('[bookService] Geographic search succeeded.');
        
        // The function now returns books + calculated_distance_meters
        const results = (Array.isArray(data) ? data : []) as (Book & { calculated_distance_meters: number })[];
        
        // Log the results including the distance
        console.log('[bookService] Returned data:', results.map(r => ({ 
          id: r.id, 
          title: r.title, 
          calculated_distance_meters: r.calculated_distance_meters 
        })));
        
        if (results.length === 0) {
          console.log('[bookService] Geographic search returned no results.');
        }
        
        // Results are already sorted by distance by the SQL function
        return results;
      }
    } else {
      // For non-geographic searches, use regular query
      console.log('[bookService] Performing non-geographic search.');
      return fallbackSearch(params);
    }
  } catch (error) {
    console.error('Error searching books:', error);
    return [];
  }
};

// Helper function for regular search (without geographic component)
const fallbackSearch = async (params: {
  title?: string;
  author?: string;
  postal_code?: string;
}): Promise<Book[]> => {
  try {
    // Start building the query
    let query = supabase.from('books').select('*');

    // Apply filters if provided
    if (params.title) {
      query = query.ilike('title', `%${params.title}%`);
    }
    
    if (params.author) {
      query = query.ilike('author', `%${params.author}%`);
    }
    
    if (params.postal_code) {
      // Fallback to exact postal code search
      query = query.eq('postal_code', params.postal_code);
    }

    // Execute the query
    const { data, error } = await query.order('created_at', { ascending: false });
    
    if (error) {
      console.error('Error searching books:', error);
      return [];
    }
    
    return data || [];
  } catch (error) {
    console.error('Error in fallback search:', error);
    return [];
  }
};

// Request a book
export const requestBook = async (
  bookId: string,
  requesterId: string
): Promise<{ success: boolean; requestId?: string; error?: string }> => {
  try {
    // First, check if the book exists
    const { data: book, error: bookError } = await supabase
      .from('books')
      .select('user_id')
      .eq('id', bookId)
      .single();
    
    if (bookError || !book) {
      return { success: false, error: 'Book not found' };
    }
    
    // Don't allow requesting your own book
    if (book.user_id === requesterId) {
      return { success: false, error: 'You cannot request your own book' };
    }
    
    // Check if a request already exists
    const { data: existingRequest, error: existingRequestError } = await supabase
      .from('book_requests')
      .select('*')
      .eq('book_id', bookId)
      .eq('requester_id', requesterId)
      .single();
      
    if (existingRequest) {
      return { success: false, error: 'You have already requested this book' };
    }
    
    // Create the request
    const { data: newRequestData, error: requestError } = await supabase
      .from('book_requests')
      .insert([
        {
          book_id: bookId,
          requester_id: requesterId,
          owner_id: book.user_id,
          status: 'pending'
        }
      ])
      .select('id')
      .single();
      
    if (requestError || !newRequestData) {
      return { success: false, error: requestError?.message || 'Failed to create request or retrieve ID' };
    }
    
    // Create a notification for the book owner
    const { error: notificationError } = await supabase
      .from('notifications')
      .insert([
        {
          user_id: book.user_id,
          type: 'book_request',
          message: `Someone has requested your book`,
          related_id: bookId,
          read: false
        }
      ]);
      
    if (notificationError) {
      console.error('Error creating notification:', notificationError);
      // We'll consider the request successful even if notification fails
    }
    
    return { success: true, requestId: newRequestData.id };
  } catch (error) {
    console.error('Error requesting book:', error);
    return { success: false, error: 'An unexpected error occurred' };
  }
};

// Cancel a book request
export const cancelBookRequest = async (
  requestId: string,
  requesterId: string // Ensure only the requester can cancel
): Promise<{ success: boolean; error?: string }> => {
  try {
    // First, verify the request exists and belongs to the requester
    const { data: request, error: fetchError } = await supabase
      .from('book_requests')
      .select('id, requester_id')
      .eq('id', requestId)
      .single();

    if (fetchError) {
      console.error('Error fetching book request for cancellation:', fetchError);
      return { success: false, error: 'Request not found or error fetching it.' };
    }

    if (!request) {
      return { success: false, error: 'Request not found.' };
    }

    if (request.requester_id !== requesterId) {
      return { success: false, error: 'You are not authorized to cancel this request.' };
    }

    // Proceed with deletion
    console.log(`[cancelBookRequest] Attempting to delete request ID: ${requestId} for user: ${requesterId}`); 
    const deleteResponse = await supabase // Store the whole response
      .from('book_requests')
      .delete()
      .eq('id', requestId);

    // Log the entire response object
    console.log(`[cancelBookRequest] Raw delete response: ${JSON.stringify(deleteResponse)}`);

    const { error: deleteError, count } = deleteResponse; // Destructure after logging

    // Keep previous log for context
    console.log(`[cancelBookRequest] Delete operation result - Error: ${JSON.stringify(deleteError)}, Count: ${count}`);

    if (deleteError) {
      console.error('Error deleting book request:', deleteError);
      return { success: false, error: deleteError.message };
    }

    // Optionally: Delete related notification? 
    // For now, we'll leave notifications as they might still be relevant history.

    return { success: true };
  } catch (error) {
    console.error('Error cancelling book request:', error);
    return { success: false, error: 'An unexpected error occurred during cancellation.' };
  }
};

// Get requested books for a user
export const getUserRequestedBooks = async (userId: string): Promise<Book[]> => {
  try {
    // First get all book requests made by this user
    const { data, error } = await supabase
      .from('book_requests')
      .select(`
        id,
        book_id,
        owner_id,
        status,
        created_at,
        books:book_id (
          id, 
          title, 
          author, 
          description, 
          condition, 
          cover_img_url, 
          location_text,
          postal_code,
          created_at
        ),
        owners:owner_id (
          id,
          full_name,
          avatar_url
        )
      `)
      .eq('requester_id', userId);
    
    if (error) {
      console.error('Error fetching requested books:', error);
      return [];
    }
    
    // Transform the data to get the books with additional request information
    const requestedBooks = data?.map(item => {
      const book = item.books as unknown as Book;
      // Add owner information to the book
      if (book) {
        book.owner = item.owners;
        // Add request information
        book.request_id = item.id;
        book.request_status = item.status;
        book.request_date = item.created_at;
      }
      return book;
    }).filter(Boolean) || [];
    
    return requestedBooks;
  } catch (error) {
    console.error('Error fetching requested books:', error);
    return [];
  }
};

// Add a new test function to check geography generation
export const testGeographyColumn = async (): Promise<{ success: boolean; message: string }> => {
  try {
    // First, query a book to see if it has a location column populated
    const { data: books, error: booksError } = await supabase
      .from('books')
      .select('*')
      .limit(5);
      
    if (booksError) throw booksError;
    
    console.log('Sample books to check location column:', books);
    
    // Then try to query using ST_DWithin to see if PostGIS is working
    if (books && books.length > 0) {
      const testLat = 37.7749;
      const testLng = -122.4194;
      const testRadius = 100000; // 100km in meters
      
      const { data: spatialBooks, error: spatialError } = await supabase.rpc(
        'books_within_distance',
        {
          lat: testLat,
          lng: testLng,
          distance_meters: testRadius
        }
      );
      
      if (spatialError) {
        console.error('Spatial query error:', spatialError);
        return { 
          success: false, 
          message: `Spatial query failed: ${spatialError.message}` 
        };
      }
      
      console.log('Spatial query results:', spatialBooks);
      
      return { 
        success: true, 
        message: `Test complete. Found ${spatialBooks?.length || 0} books within 100km of San Francisco` 
      };
    }
    
    return { success: false, message: 'No books found to test' };
  } catch (error) {
    console.error('Error testing geography column:', error);
    return { 
      success: false, 
      message: error instanceof Error ? error.message : 'Unknown error occurred' 
    };
  }
}; 